"use strict";const wPost=(e,...t)=>postMessage({type:e,payload:t}),installAsyncProxy=function(){const e=function(...e){throw new Error(e.join(" "))};globalThis.window===globalThis?e("This code cannot run from the main thread.","Load it as a Worker from a separate Worker."):navigator?.storage?.getDirectory||e("This API requires navigator.storage.getDirectory.");const t=Object.create(null);t.verbose=1;const n={0:console.error.bind(console),1:console.warn.bind(console),2:console.log.bind(console)},s=(e,...s)=>{t.verbose>e&&n[e]("OPFS asyncer:",...s)},a=(...e)=>s(2,...e),i=(...e)=>s(1,...e),o=(...e)=>s(0,...e),r=Object.create(null),c=new Set,l=function(e,t){const n=new URL(e,"file://irrelevant").pathname;return t?n.split("/").filter((e=>!!e)):n},d=async function(e,n=!1){const s=l(e,!0),a=s.pop();let i=t.rootDir;for(const e of s)e&&(i=await i.getDirectoryHandle(e,{create:!!n}));return[i,a]},f=async e=>{if(e.syncHandle){a("Closing sync handle for",e.filenameAbs);const t=e.syncHandle;return delete e.syncHandle,delete e.xLock,c.delete(e.fid),t.close()}},y=async e=>{try{await f(e)}catch(t){i("closeSyncHandleNoThrow() ignoring:",t,e)}},u=async()=>{if(c.size)for(const e of c){const t=r[e];await y(t),a("Auto-unlocked",e,t.filenameAbs)}},E=async e=>{if(e.releaseImplicitLocks&&c.has(e.fid))return y(e)};class b extends Error{constructor(e,...t){super([...t,": "+e.name+":",e.message].join(" "),{cause:e}),this.name="GetSyncHandleError"}}b.convertRc=(e,n)=>{if(e instanceof b){if("NoModificationAllowedError"===e.cause.name||"DOMException"===e.cause.name&&0===e.cause.message.indexOf("Access Handles cannot"))return t.sq3Codes.SQLITE_BUSY;if("NotFoundError"===e.cause.name)return t.sq3Codes.SQLITE_CANTOPEN}else if("NotFoundError"===e?.name)return t.sq3Codes.SQLITE_CANTOPEN;return n};const w=async(e,n)=>{if(!e.syncHandle){const s=performance.now();a("Acquiring sync handle for",e.filenameAbs);const o=6,r=2*t.asyncIdleWaitTime;let l=1,d=r;for(;;d=r*++l)try{e.syncHandle=await e.fileHandle.createSyncAccessHandle();break}catch(s){if(l===o)throw new b(s,"Error getting sync handle for",n+"().",o,"attempts failed.",e.filenameAbs);i("Error getting sync handle for",n+"(). Waiting",d,"ms and trying again.",e.filenameAbs,s),Atomics.wait(t.sabOPView,t.opIds.retry,0,d)}a("Got",n+"() sync handle for",e.filenameAbs,"in",performance.now()-s,"ms"),e.xLock||(c.add(e.fid),a("Acquired implicit lock for",n+"()",e.fid,e.filenameAbs))}return e.syncHandle},O=(e,n)=>{a(e+"() => notify(",n,")"),Atomics.store(t.sabOPView,t.opIds.rc,n),Atomics.notify(t.sabOPView,t.opIds.rc)},g=function(t,n){n.readOnly&&e(t+"(): File is read-only: "+n.filenameAbs)};let h=!1;const p={"opfs-async-shutdown":async()=>{h=!0,O("opfs-async-shutdown",0)},mkdir:async e=>{let n=0;try{await d(e+"/filepart",!0)}catch(e){t.s11n.storeException(2,e),n=t.sq3Codes.SQLITE_IOERR}O("mkdir",n)},xAccess:async e=>{let n=0;try{const[t,n]=await d(e);await t.getFileHandle(n)}catch(e){t.s11n.storeException(2,e),n=t.sq3Codes.SQLITE_IOERR}O("xAccess",n)},xClose:async function(e){c.delete(e);const n=r[e];let s=0;if(n){if(delete r[e],await f(n),n.deleteOnClose)try{await n.dirHandle.removeEntry(n.filenamePart)}catch(e){i("Ignoring dirHandle.removeEntry() failure of",n,e)}}else t.s11n.serialize(),s=t.sq3Codes.SQLITE_NOTFOUND;O("xClose",s)},xDelete:async function(...e){const t=await p.xDeleteNoWait(...e);O("xDelete",t)},xDeleteNoWait:async function(e,n=0,s=!1){let a=0;try{for(;e;){const[t,a]=await d(e,!1);if(!a)break;if(await t.removeEntry(a,{recursive:s}),4660!==n)break;s=!1,(e=l(e,!0)).pop(),e=e.join("/")}}catch(e){t.s11n.storeException(2,e),a=t.sq3Codes.SQLITE_IOERR_DELETE}return a},xFileSize:async function(e){const n=r[e];let s=0;try{const e=await(await w(n,"xFileSize")).getSize();t.s11n.serialize(Number(e))}catch(e){t.s11n.storeException(1,e),s=b.convertRc(e,t.sq3Codes.SQLITE_IOERR)}await E(n),O("xFileSize",s)},xLock:async function(e,n){const s=r[e];let a=0;const i=s.xLock;if(s.xLock=n,!s.syncHandle)try{await w(s,"xLock"),c.delete(e)}catch(e){t.s11n.storeException(1,e),a=b.convertRc(e,t.sq3Codes.SQLITE_IOERR_LOCK),s.xLock=i}O("xLock",a)},xOpen:async function(e,n,s,a){const i="xOpen",c=t.sq3Codes.SQLITE_OPEN_CREATE&s;try{let o,l;try{[o,l]=await d(n,!!c)}catch(e){return t.s11n.storeException(1,e),void O(i,t.sq3Codes.SQLITE_NOTFOUND)}if(t.opfsFlags.OPFS_UNLINK_BEFORE_OPEN&a)try{await o.removeEntry(l)}catch(e){}const f=await o.getFileHandle(l,{create:c}),y=Object.assign(Object.create(null),{fid:e,filenameAbs:n,filenamePart:l,dirHandle:o,fileHandle:f,sabView:t.sabFileBufView,readOnly:!c&&!!(t.sq3Codes.SQLITE_OPEN_READONLY&s),deleteOnClose:!!(t.sq3Codes.SQLITE_OPEN_DELETEONCLOSE&s)});y.releaseImplicitLocks=a&t.opfsFlags.OPFS_UNLOCK_ASAP||t.opfsFlags.defaultUnlockAsap,r[e]=y,O(i,0)}catch(e){o(i,e),t.s11n.storeException(1,e),O(i,t.sq3Codes.SQLITE_IOERR)}},xRead:async function(e,n,s){let a,i=0;const c=r[e];try{a=(await w(c,"xRead")).read(c.sabView.subarray(0,n),{at:Number(s)}),a<n&&(c.sabView.fill(0,a,n),i=t.sq3Codes.SQLITE_IOERR_SHORT_READ)}catch(e){o("xRead() failed",e,c),t.s11n.storeException(1,e),i=b.convertRc(e,t.sq3Codes.SQLITE_IOERR_READ)}await E(c),O("xRead",i)},xSync:async function(e,n){const s=r[e];let a=0;if(!s.readOnly&&s.syncHandle)try{await s.syncHandle.flush()}catch(e){t.s11n.storeException(2,e),a=t.sq3Codes.SQLITE_IOERR_FSYNC}O("xSync",a)},xTruncate:async function(e,n){let s=0;const a=r[e];try{g("xTruncate",a),await(await w(a,"xTruncate")).truncate(n)}catch(e){o("xTruncate():",e,a),t.s11n.storeException(2,e),s=b.convertRc(e,t.sq3Codes.SQLITE_IOERR_TRUNCATE)}await E(a),O("xTruncate",s)},xUnlock:async function(e,n){let s=0;const a=r[e];if(a.syncHandle&&t.sq3Codes.SQLITE_LOCK_NONE===n)try{await f(a)}catch(e){t.s11n.storeException(1,e),s=t.sq3Codes.SQLITE_IOERR_UNLOCK}O("xUnlock",s)},xWrite:async function(e,n,s){let a;const i=r[e];try{g("xWrite",i),a=n===(await w(i,"xWrite")).write(i.sabView.subarray(0,n),{at:Number(s)})?0:t.sq3Codes.SQLITE_IOERR_WRITE}catch(e){o("xWrite():",e,i),t.s11n.storeException(1,e),a=b.convertRc(e,t.sq3Codes.SQLITE_IOERR_WRITE)}await E(i),O("xWrite",a)}},I=async function(){const n=Object.create(null);for(let e of Object.keys(t.opIds)){const s=p[e];if(!s)continue;const a=Object.create(null);n[t.opIds[e]]=a,a.key=e,a.f=s}for(;!h;)try{if("not-equal"!==Atomics.wait(t.sabOPView,t.opIds.whichOp,0,t.asyncIdleWaitTime)){await u();continue}const s=Atomics.load(t.sabOPView,t.opIds.whichOp);Atomics.store(t.sabOPView,t.opIds.whichOp,0);const a=n[s]??e("No waitLoop handler for whichOp #",s),i=t.s11n.deserialize(!0)||[];a.f?await a.f(...i):o("Missing callback for opId",s)}catch(e){o("in waitLoop():",e)}};navigator.storage.getDirectory().then((function(n){t.rootDir=n,globalThis.onmessage=function({data:n}){switch(n.type){case"opfs-async-init":{const s=n.args;for(const e in s)t[e]=s[e];t.verbose=s.verbose??1,t.sabOPView=new Int32Array(t.sabOP),t.sabFileBufView=new Uint8Array(t.sabIO,0,t.fileBufferSize),t.sabS11nView=new Uint8Array(t.sabIO,t.sabS11nOffset,t.sabS11nSize),Object.keys(p).forEach((n=>{Number.isFinite(t.opIds[n])||e("Maintenance required: missing state.opIds[",n,"]")})),(()=>{if(t.s11n)return t.s11n;const n=new TextDecoder,s=new TextEncoder("utf-8"),a=new Uint8Array(t.sabIO,t.sabS11nOffset,t.sabS11nSize),i=new DataView(t.sabIO,t.sabS11nOffset,t.sabS11nSize);t.s11n=Object.create(null);const o=Object.create(null);o.number={id:1,size:8,getter:"getFloat64",setter:"setFloat64"},o.bigint={id:2,size:8,getter:"getBigInt64",setter:"setBigInt64"},o.boolean={id:3,size:4,getter:"getInt32",setter:"setInt32"},o.string={id:4};const r=t=>{switch(t){case o.number.id:return o.number;case o.bigint.id:return o.bigint;case o.boolean.id:return o.boolean;case o.string.id:return o.string;default:e("Invalid type ID:",t)}};t.s11n.deserialize=function(e=!1){const s=a[0],o=s?[]:null;if(s){const e=[];let c,l,d,f=1;for(c=0;c<s;++c,++f)e.push(r(a[f]));for(c=0;c<s;++c){const s=e[c];s.getter?(d=i[s.getter](f,t.littleEndian),f+=s.size):(l=i.getInt32(f,t.littleEndian),f+=4,d=n.decode(a.slice(f,f+l)),f+=l),o.push(d)}}return e&&(a[0]=0),o},t.s11n.serialize=function(...n){if(n.length){const c=[];let l=0,d=1;for(a[0]=255&n.length;l<n.length;++l,++d)c.push((r=n[l],o[typeof r]||e("Maintenance required: this value type cannot be serialized.",r))),a[d]=c[l].id;for(l=0;l<n.length;++l){const e=c[l];if(e.setter)i[e.setter](d,n[l],t.littleEndian),d+=e.size;else{const e=s.encode(n[l]);i.setInt32(d,e.byteLength,t.littleEndian),d+=4,a.set(e,d),d+=e.byteLength}}}else a[0]=0;var r},t.s11n.storeException=t.asyncS11nExceptions?(e,n)=>{e<=t.asyncS11nExceptions&&t.s11n.serialize([n.name,": ",n.message].join(""))}:()=>{},t.s11n})(),a("init state",t),wPost("opfs-async-inited"),I();break}case"opfs-async-restart":h&&(i("Restarting after opfs-async-shutdown. Might or might not work."),h=!1,I())}},wPost("opfs-async-loaded")})).catch((e=>o("error initializing OPFS asyncer:",e)))};globalThis.SharedArrayBuffer?globalThis.Atomics?globalThis.FileSystemHandle&&globalThis.FileSystemDirectoryHandle&&globalThis.FileSystemFileHandle&&globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle&&navigator?.storage?.getDirectory?installAsyncProxy():wPost("opfs-unavailable","Missing required OPFS APIs."):wPost("opfs-unavailable","Missing Atomics API.","The server must emit the COOP/COEP response headers to enable that."):wPost("opfs-unavailable","Missing SharedArrayBuffer API.","The server must emit the COOP/COEP response headers to enable that.");